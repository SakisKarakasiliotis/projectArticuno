Package sablecc;

Helpers
  dollar = '$';
  doubledollar = '$$';
  tab = 9;
  cr = 13;
  lf = 10;
  eos = 0;
  sq = 39;
  dq = 34;
  lowercase_ch = ['a'..'z'];
  uppercase_ch = ['A'..'Z'];
  number = ['0'..'9'];
  backslash = '\';
  underscore = '_';
  alpha_num = lowercase_ch | uppercase_ch | number;
  any = [0 .. 0xFFFF];
  escape_char = eos|sq|dq|tab|cr|lf;
  eol = cr lf | cr | lf;
  not_cr_lf = [any - [cr + lf]];
  not_dollar = [not_cr_lf - dollar];
Tokens
//Keywords Definitions
  kw_fun = 'fun';
  kw_var = 'var';
  kw_char = 'char';
  kw_int = 'int';
  kw_do = 'do';
  kw_while = 'while';
  kw_if = 'if';
  kw_else = 'else';
  kw_then = 'then';
  kw_ref = 'ref';
  kw_nothing = 'nothing';
  kw_return = 'return';

//Symbols
  lbrace = '{';
  rbrace = '}';
  lparen = '(';
  rparen = ')';
  lbracket = '[';
  rbracket = ']';
  comma = ',';
  semicolon = 59;
  colon = ':';
  assign = '<-';
  plus = '+';
  minus = '-';
  mult = '*';
  division = '/';
  kw_mod = 'mod';
  kw_div = 'div';
  kw_and = 'and';
  kw_or = 'or';
  not_equal = '#';
  equals = '=';
  less_than = '<';
  less_than_equal = '<=';
  greater_than = '>';
  greater_than_equal = '>=';
  kw_not = 'not';

//Names
  identifier = (lowercase_ch|uppercase_ch) (alpha_num|underscore)*;
  int_const = (number)*;
  char_const = sq (escape_char | alpha_num) sq;
  string_literal = dq (escape_char | alpha_num | any)+ dq;

//Ignored and Comments
  whitespace = ' ' | cr | lf | tab;
  comment = dollar not_dollar not_cr_lf* eol;
  comments = doubledollar any* doubledollar;

Ignored Tokens
  whitespace,
  comment,
  comments;

Productions
  program = function_definition;

  function_definition = header local_definition* block;

  header = kw_fun identifier lparen fpar_definition? next_fpar_definition* rparen colon ret_type;

  local_definition = {f_def} function_definition |
                     {f_decl} function_declaration |
                     {var_def} var_definition;

  block = lbrace statement* rbrace;

  fpar_definition = kw_ref? identifier  next_identifier* colon fpar_type;

  next_fpar_definition = semicolon fpar_definition;

  ret_type = {data_type} data_type |
             {nothing} kw_nothing;

  data_type = {integer} kw_int|
              {character} kw_char;

  type = data_type array_size*;

  function_declaration = header semicolon;

  fpar_type = data_type empty_brackets? array_size*;

  var_definition = kw_var identifier next_identifier* colon type semicolon;

  next_identifier = comma identifier;

  statement = {noop} semicolon |
              {assignment} l_value assign expression semicolon |
              {if} if_stmt |
              {block} block |
              {f_call} func_call semicolon |
              {while_do} kw_while condition kw_do statement |
              {return} kw_return expression? semicolon;

  if_stmt = {no_else} kw_if condition kw_then [then_stmt]:statement |
            {with_else} kw_if condition kw_then [then_stmt]:stmt_with_else kw_else [else_stmt]:statement;

  stmt_with_else = {noop} semicolon |
                   {assignment} l_value assign expression semicolon |
                   {if} if_else_stmt |
                   {block} block |
                   {f_call} func_call semicolon |
                   {while_do} kw_while condition kw_do stmt_with_else |
                   {return} kw_return expression? semicolon;

  if_else_stmt = kw_if condition kw_then [then_stmt]:stmt_with_else kw_else [else_stmt]:stmt_with_else;

  func_call = identifier lparen multiple_expressions? rparen;

  l_value = {identifier} identifier |
            {string_lit} string_literal |
            {array_assign} l_value lbracket expression? rbracket;

  expression = {array} array |
               {string}string_literal |
               {char_const} char_const |
               {f_call} func_call |
               {paren_expression} lparen expression_b rparen |
               {signed_expression} sign expression |
               {num_oper} n_exp;

  expression_b = {array} array |
                 {string}string_literal |
                 {char_const} char_const |
                 {f_call} func_call |
                 {signed_expression} sign expression;

  condition = {cond_exp}  comp_exp;

  sign = {plus} plus |
         {minus} minus ;

  next_expression = comma expression;

  multiple_expressions = expression next_expression*;

  array_size = lbracket int_const rbracket;

  empty_brackets = lbracket rbracket;

  array = identifier  array_position+;

  array_position = lbracket expression rbracket;

  logic_operations = {or} kw_or |
                      {and} kw_and |
                      {not} kw_not;

  comparison_symbols = {equals} equals|
                       {not_equals} not_equal|
                       {less_than} less_than|
                       {greater_than} greater_than|
                       {greater_or_equal} greater_than_equal|
                       {less_or_equal} less_than_equal;

 n_exp = {plus_exp} n_exp plus term |
         {minus_exp}  n_exp minus term |
         {term}  term;

 term = {term_mult} term mult exponent |
        {term_div} term kw_div exponent |
        {term_mod} term kw_mod exponent |
        {exponent} exponent;

 exponent = {unsigned} final;

 final = {non_paren} int_const |
         {paren_exp} lparen n_exp rparen |
         {iden}identifier;

 comp_exp = {or_exp}comp_exp kw_or comp_term |{no_or_exp} comp_term;

 comp_term = {and_expr}comp_term kw_and comp_fun |{no_and_exp} comp_fun;

 comp_fun = {not_exp}kw_not comp_fun |
            {no_not_exp} comp_val ;

 comp_val = {equals}comp_val equals comp_final |
            {not_equals} comp_val not_equal comp_final |
            {less_than} comp_val less_than comp_final |
            {greater_than} comp_val greater_than comp_final |
            {greater_or_equal} comp_val greater_than_equal comp_final |
            {less_or_equal} comp_val less_than_equal comp_final |
            {no_comp_exp} comp_final;

 comp_final = {expr}expression ;