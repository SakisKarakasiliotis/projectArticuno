Package sablecc;

Helpers
  tab = 9;
  cr = 13;
  lf = 10;
  eos = 0;
  sq = 39;
  dq = 34;
  lowercase_ch = ['a'..'z'];
  uppercase_ch = ['A'..'Z'];
  number = ['0'..'9'];
  backslash = '\';
  underscore = '_';
  alpha_num = lowercase_ch | uppercase_ch | number;
  any = [0..127];
  escape_char = eos|sq|dq|tab|cr|lf;

Tokens
  fun = 'fun';
  var = 'var';
  char = 'char';
  int = 'int';
  do = 'do';
  while = 'while';
  if = 'if';
  else = 'else';
  then = 'then';
  ref = 'ref';
  nothing = 'nothing';
  return = 'return';
  lbrace = '{';
  rbrace = '}';
  lparen = '(';
  rparen = ')';
  lbracket = '[';
  rbracket = ']';
  comma = ',';
  semicolon = 59;
  colon = ':';
  assign = '<-';
  plus = '+';
  minus = '-';
  mult = '*';
  division = '/';
  mod = 'mod';
  div = 'div';
  and = 'and';
  or = 'or';
  not_equal = '#';
  equals = '=';
  less_than = '<';
  less_than_equal = '<=';
  greater_than = '>';
  greater_than_equal = '>=';
  not = 'not';
  identifier = (lowercase_ch|uppercase_ch) (alpha_num|underscore)*;
  int_const = (number)*;
  char_const = sq (escape_char | alpha_num) sq;
  string_literal = dq (escape_char | alpha_num | any)* dq;
  whitespace = ' ' | cr | lf | tab;


Ignored Tokens
  whitespace;

Productions
  program = function_definition;
  function_definition = header local_definition* block;
  header = fun identifier lparen fpar_definition next_fpar_definition* rparen colon ret_type;
  fpar_definition = ref identifier  next_identifier* colon fpar_type;
  data_type = {integer} int| {character} char;
  type = data_type array_size*;
  ret_type = {data_type} data_type |{nothing} nothing;
  fpar_type = data_type empty_brackets? array_size*;
  local_definition ={f_def} function_definition |{f_decl} function_declaration |{var_def} var_definition;
  var_definition = var identifier next_identifier* colon type semicolon;
  function_declaration = header semicolon;
  statement = {semicolon} semicolon |{assignment} l_value assign expression semicolon |{block} block |{f_call} func_call semicolon |{if_stmt} if_stmt |{while_do} while condition do statement |{return} return expression? semicolon;
  block = lbrace statement* rbrace;
  func_call = identifier lparen multiple_expressions? rparen;
  l_value = {identifier} identifier |{string_lit} string_literal |{array_assign} l_value lbracket expression? rbracket;
  expression = {int_const} int_const |{char_const} char_const |{l_value} l_value |{f_call} func_call |{paren_expression} lparen expression rparen |{signed_expression} sign expression |{num_operation} [first]:expression num_operations [second]:expression;
  condition ={paren_cond} lparen condition rparen |{not_condition} not condition |{logic_operation} [first]:condition logic_operations [second]:condition |{comparison} [first]:expression comparison_symbols [second]:expression;



  next_fpar_definition = semicolon fpar_definition;
  next_identifier = comma identifier;
  next_expression = comma expression;
  multiple_expressions = expression next_expression*;
  array_size = lbracket int_const rbracket;
  empty_brackets = lbracket rbracket;
  if_stmt ={matched} matched |{unmatched} unmatched;
  unmatched = {if_simple}if condition statement |{if_m_else_u} if condition matched else unmatched;
  matched = {if_m_else_m}if condition [if_matched]:matched else [else_matched]:matched|{statement}statement;
  sign = {plus} plus |{minus} minus;
  num_operations ={plus} plus |{minus} minus |{mult} mult |{mod} mod |{div} div ;
  logic_operations = {or} or | {and} and ;
  comparison_symbols = {equals} equals|{not_equals} not_equal|{less_than} less_than|{greater_than} greater_than|{greater_or_equal} greater_than_equal|{less_or_equal} less_than_equal;
